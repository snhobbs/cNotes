\documentclass{notes}
\begin{document}

\chapter{Data Types}

		\rsrc{C Keywords} \href{http://tigcc.ticalc.org/doc/keywords.html}{Link}

\rsrc{Wiki data types}\href{https://en.wikipedia.org/wiki/C_data_types}{Wiki Link}

	\begin{questions}{Basic Types}
		
		\begin{questionAnswer}
			\qItem{int}{Integer, reflects the size of a word on the current architecture. Atleast 16 bits}
			\qItem{char}{8 bit value}
			\qItem{short}{Short integer, atleast 16 bits.}
			\qItem{long}{Long integer, atleast 32 bits}
			\qItem{long long}{Extra long integer, atleast 64 bits, in version $>=$ c99}
			\qItem{float}{Single persision float}
			\qItem{double}{Double percision float}
			\qItem{long double}{Maps to either a quadruple precision floating point or defaults to a double depending on the compiler}
		\end{questionAnswer}
	\end{questions}

	\begin{questions}{Signed values}

		\rsrc{Wikipedia Two's Compliment}\href{https://en.wikipedia.org/wiki/Two's_complement}{Wiki Link}

		\begin{questionAnswer}
			\qItem{signed}{Plain declarations to the above data types default to signed, 2's compliment values}
			\qItem{unsigned}{Use: unsigned \opt{data type} for an unsigned value}
		\end{questionAnswer}
	\end{questions}

	\begin{questions}{Fixed-width integer types}
		These types are found in \opt{inttypes.h}/\opt{cinttypes}, they are also in \opt{stdint.h}/\opt{cstdint}. These data types allow for specified lengths of 8, 16, 32, 64 and higher if supported.

		\rsrc{C$++$ Ref}\href{http://www.cplusplus.com/reference/cinttypes/}{Link}
		\begin{questionAnswer}
			\qItem{intmax\_t}{Largest supported integer}
			\qItem{int\opt{N}\_t}{Specified integer length of \opt{N} bits. NOTE: Optional}
			\qItem{int\_least\opt{N}\_t}{Integer of $<=$ \opt{N}}
			\qItem{int\_fast\opt{N}\_t}{Fastest signed integer type with a width of at least \opt{N}}
			\qItem{intptr\_t}{Large enough to handle any pointer. NOTE: Optional}
		\end{questionAnswer}
	\end{questions}	

	\begin{questions}{Booleans}
		\rsrc{C$++$ Ref}\href{http://www.cplusplus.com/reference/cstdbool/}{Link}

		c99 added type \_Bool which is either 1 or 0. Using the header \opt{stdbool.h}/\opt{cstdbool} the data type bool is defined as is true/false.	


	\end{questions}

	\begin{questions}{Pointers}
		
		\rsrc{Wikipedia}\url{https://en.wikipedia.org/wiki/Pointer_(computer_programming)#C_and_C.2B.2B}
	
		\begin{questionAnswer}
			\qItem{Pointer}{ }
			\qItem{Function pointers}{ }
		\end{questionAnswer}
	\end{questions}

	\begin{questions}{Type Qualifiers}

		\rsrc{Type Qualifiers}\href{https://en.wikipedia.org/wiki/Type_qualifier}{Wiki Link}

		A type qualifier is a keyword that is applied to a type, resulting in a qualified type. 
		\begin{questionAnswer}
			\qItem{volatile}{$>=$C89 \& C++. Indicates that an object may be changed by something external to the program at any time and so must be re-read from memory every time it is accessed}
			\qItem{const}{$>=$C89 \& C++. Makes variable value or pointer parameter unmodifiable. Use: const \opt{var} [= \opt{value}];. The value can be indirectly modified with a pointer argument: *(int*)\&\opt{vat} = \opt{value};}
			\qItem{restrict}{$>=$C99, Restrict declares that for the lifetime of the pointer, only the pointer itself or a value directly derived from it (such as pointer + 1) will be used to access the object to which it points. This limits the effects of pointer aliasing, aiding optimizations. Non standard in C++ (gcc uses \_\_restrict\_\_)}
			\qItem{\_Atomic}{$>=$C11 \opt{stdatomic.h}, in C++ with \opt{atomic}. The atomic library provides components for fine-grained atomic operations allowing for lockless concurrent programming. Each atomic operation is indivisible with regards to any other atomic operation that involves the same object. Atomic objects are free of data races. Useful for multithreaded code \href{http://en.cppreference.com/w/c/language/atomic}{C++ ref}}
		\end{questionAnswer}
	\end{questions}

	\begin{questions}{Storage Classes}
		
		\rsrc{C storage classes} \href{http://www.tutorialspoint.com/cprogramming/c_storage_classes.htm}{Link}

		\begin{questionAnswer}
			\qItem{auto}{Default storage class for all local variables. }
			\qItem{register}{Tells the compiler to try and use a CPU register for the variable as to optimize access to that variable. If optimization is turned on this is done automatically. Use: register \opt{data type} \opt{var}; NOTE: it is not possible to take the address of a register variable.}
			\qItem{extern}{Indicates that an identifier is defined elsewhere. Same as a global in python. extern is used by default for function definitions.  When you use 'extern', the variable cannot be initialized however, it points the variable name at a storage location that has been previously defined.}
			\qItem{static}{Instructs the compiler to keep a local variable in existence during the life-time of the program instead of creating and destroying it each time it comes into and goes out of scope. Therefore, making local variables static allows them to maintain their values between function calls.}
			\qItem{Allocated memory}{Memory reserved with malloc/free. Located on the heap, in existance until freed}
		\end{questionAnswer}
	\end{questions}
	\chapter{Memory Management}

	\rsrc{Heap v. Stack}\href{http://www.gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html}{Gribble Lab}
\end{document}
